#!/usr/bin/python

rule make_pop_list:
    input:
        snpweights = 'snpweights/samples.snpweights.csv',
        samp_to_sub = 'subject_level/SampleUsedforSubject.csv',
        fam = 'remove_related/subjects.fam',
        SampSheet = sample_sheet
    output:
        snpweights = 'ancestry/subjects.snpweights.csv',
        ADMIXED_EUR = 'split_by_pop/ADMIXED_EUR.keep.txt',
        ADMIXED_ASN = 'split_by_pop/ADMIXED_ASN.keep.txt',
        ADMIXED_AFR = 'split_by_pop/ADMIXED_AFR.keep.txt',
        ASN_EUR = 'split_by_pop/ASN_EUR.keep.txt',
        AFR_EUR = 'split_by_pop/AFR_EUR.keep.txt',
        AFR_ASN = 'split_by_pop/AFR_ASN.keep.txt',
        AFR_ASN_EUR = 'split_by_pop/AFR_ASN_EUR.keep.txt',
        EUR = 'split_by_pop/EUR.keep.txt',
        ASN = 'split_by_pop/ASN.keep.txt',
        AFR = 'split_by_pop/AFR.keep.txt'
    run:
        SubjectToCaCoDict = makeSubjectToCaCoDict(sample_sheet)
        sampToSubDict = MakeSampToSubDict(input.samp_to_sub)
        subDict = {}
        with open(input.fam) as f:
            for line in f:
                sub = line.split()[1]
                subDict[sub] = 1
        ancestryDict = {}
        for pop in POPS:
            ancestryDict[pop] = []
        with open(input.snpweights) as f, open(output.snpweights, 'w') as out:
            head = f.readline()
            out.write('ID,CaCo,SNPs,EV1,EV2,AFR,EUR,ASN,Ancestry\n')
            line = f.readline()
            while line != '':
                line_list = line.rstrip().split(',')
                samp = line_list[0]
                ancestry = line_list[-1]
                if sampToSubDict.get(samp):
                    sub = sampToSubDict[samp]
                    if subDict.get(sub):
                        sub = line_list[0]
                        CaCo = SubjectToCaCoDict[sub]
                        if CaCo == 'NA':
                            CaCo = '2'
                        line_list[1] = CaCo
                        ancestryDict[ancestry].append(sub)
                        out.write(','.join(line_list) + '\n')
                line = f.readline()
        for pop in POPS:
            subjects = ancestryDict[pop]
            with open('split_by_pop/' + pop + '.keep.txt', 'w') as out:
                for sub in subjects:
                    out.write(sub + ' ' + sub + '\n')

rule plink_subset_pop:
    input:
        bed = 'remove_related/subjects.bed',
        bim = 'remove_related/subjects.bim',
        fam = 'remove_related/subjects.fam',
        keep = 'split_by_pop/{pop}.keep.txt'
    params:
        inProj = 'remove_related/subjects',
        outProj = 'split_by_pop/{pop}_subjects'
    output:
        'split_by_pop/{pop}_subjects.bed',
        'split_by_pop/{pop}_subjects.bim',
        'split_by_pop/{pop}_subjects.fam'
    run:
        c = 0
        with open(input.keep) as f:
            for line in f:
                c += 1
        if c < int(config['minimum_pop_subjects']):
            for x in output:
                with open(x, 'w') as out:
                    out.write('Too few subjects to process pop\n')
        else:
            shell('plink --bfile {params.inProj} --keep {input.keep} --memory 10000 --make-bed --out {params.outProj}')

